## 为什么不推荐使用外键与级联
* 当触发主键更新时，同时触发外键的更新，即为级联更新。外键与级联更新适用于单机低并发、不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险，外键影响数据库的插入速度。
* 每次delete和update都得考虑外键约束，增加了复杂性，
* 分库分表下外键是无法生效的

## 存储过程
* 可以把存储过程看成是一些SQL语句的集合，中间加了点逻辑控制语句。
* 存储过程一旦调试完成通过后就能稳定运行，运行快因为是预编译过的。
* 难以调试和扩展，没有移植性（阿里巴巴开发手册）

## drop、delete 和 truncate
* truncate和不带where子句的delete以及drop都会删除表内的数据，但是truncate和delete只删除数据不删除表的结构，drop会删除表的结构。
* truncate和drop是DDL数据定义语言，不能回滚，不触发trigger。delete语句是DML（数据库操作语句），会放到rollback segment中，事务提交之后生效。

## SQL 和 NoSQL
||SQL|NoSQL|
|:--:|:--:|:--:|
|数据存储模型|结构化存储，具有固定行和列的表格|非结构化存储。JSON、键值对、图、表|
|发展历程|开发于1970年代，重点是减少数据重复|开发于2000年后期，重点是提升可扩展性，减少大规模数据的存储成本|
|例子|Oracle、MySQL、SQL Server、PostgreSQL等|Redis、MongoDB等|
|ACID属性|提供原子性、一致性、隔离性和持久性|通常不支持ACID事务|
|性能|性能取决于磁盘子系统，要获得最佳性能，通常需要优化查询、索引和表结构|性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定|
|扩展|垂直(使用性能更强大的服务器)、读写分离、分库分表|横向（增加服务器的方式横向扩展，通常是基于分片机制）|
|用途|普通企业级的项目的数据存储|用途广泛，比如图数据库支持分析和遍历连接数据之间的关系、键值对数据库可以处理大量数据扩展和极高的状态变化|
|查询语句|结构化查询语句（SQL）|数据访问语法可能因数据库而异|

## MySQL存储引擎
* 插件式架构，支持多种存储引擎，存储引擎是基于表的，而不是数据库。
* MyISAM 和 InnoDB区别

|区别|MyIASM|InnoDB|
|:--:|:--:|:--:|
|行级锁|不支持|支持|
|事务|不支持|支持|
|外键|不支持|支持|
|数据库异常崩溃后的安全恢复|不支持|支持|
|MVCC|不支持|支持|
|索引实现方式|B+tree，非聚簇索引|数据文件本身就是索引文件，聚簇索引|
|性能|较低|更好|

## MySQL索引
* 使用索引可以大大加快数据检索速度，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
* 创建索引和维护索引需要耗费许多时间，如果修改的数据有索引，那么索引也需要修改，降低SQL执行效率。
* 占用物理内存
* 索引类型：Hash表、BST、AVL、红黑树、B和B+树、跳表

## B和B+树
* B树的所有节点既存放key也存放数据，而B+树只有叶子节点存放key和data，其他节点只存放key。
* B树的叶子节点都是独立的，B+树的叶子节点顺序相连
* B树的检索过程相当于对范围内的每个节点的关键字做二分查找不一定到叶子节点，B+树的检索一定到叶子节点。
* B+树的范围查询只需要对叶子链表进行遍历即可，B树需要先进行查找下限，然后中序遍历直到上限。
  
## 聚簇索引和非聚簇索引
* 聚簇索引是索引结构和数据一起存放的索引，并不是一种单独的索引类型，比如InnoDB的主键索引。
* 聚簇索引查询速度快，对排序查找和范围查找优化，依赖于有序数据，更新代价大。
* 非聚簇索引是索引结构和数据分开存放的索引，并不是一种单独的索引类型，二级索引（辅助索引）就属于非聚簇索引。
* 非聚簇索引更新代价比聚簇索引小，叶子节点不存放数据。
* 非聚簇索引依赖有序的数据，会二次查询（回表），当查到索引对应的指针或主键后，可能还需要再到数据文件或表中查询。
![image](https://github.com/Ray3260/Blog/assets/41173822/14b62e70-8164-4a0a-92ba-693c8a522f56)

## 覆盖索引和联合索引
* 覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引就可以查到数据了，无需回表查询。
* 联合索引使用表中的多个字段创建索引

## 最左前缀匹配原则
* 在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中匹配。可以将区分度高的字段放在最左边，过滤更多数据。

## 索引使用建议
* 选择合适的字段创建索引
  * 不为 NULL 的字段
  * 被频繁查询的字段
  * 被作为条件查询的字段
  * 频繁需要排序的字段
  * 被经常频繁用于连接的字段
* 被频繁更新的字段应该慎重建立索引
* 限制每张表上的索引数量
* 尽可能的考虑建立联合索引而不是单列索引
* 注意避免冗余索引
* 字符串类型的字段使用前缀索引代替普通索引
* 避免索引失效
* 删除长期未使用的索引
* 分析语句是否走索引查询

## MySQL事务隔离级别
* READ-UNCOMMITED(读未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
* READ-COMMITED(读已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，还是可能发生幻读或不可重复读。
* Repeatable-read(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，幻读仍能发生。
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACI的D隔离级别，所有事务依次执行。
* InnoDB默认支持的隔离级别是可重复读。快照读通过MVCC机制保证不出现幻读。当前读使用next-key lock（行锁（record lock）和间隙锁（Gap lock）的结合）进行加锁保证不出现幻读。
* 在使用分布式事务时必须设置SERIALIZABLE隔离级别。

|隔离级别|脏读|不可重复读|幻读|
|:--:|:--:|:--:|:--:|
|读未提交|&#x2714;|&#x2714;|&#x2714;|
|读已提交|&#x2716;|&#x2714;|&#x2714;|
|可重复读|&#x2716;|&#x2716;|&#x2714;|
|可串行化|&#x2716;|&#x2716;|&#x2716;|

