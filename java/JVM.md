## 运行时数据区域
* 线程共享：
  * 堆: java虚拟机管理的内存最大的一块，在虚拟机启动时创建，存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
    * 是垃圾收集器管理的主要区域，根据分代垃圾收集算法，还可以分为新生代和老年代（Eden、Survivor、Old）
  * 方法区: 存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据
  * 直接内存：特殊的内存缓冲区，通过JNI在本地内存上分配的，并不是运行时数据区的一部分
* 线程私有：
  * *程序计数器* ：是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
    * 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
    * 在多线程情况下，程序计数器用来记录当前线程执行的位置，保证线程上下文切换正确。
    * 程序计数器是唯一不会出现OOM的内存区域。
    
  * 虚拟机栈：
    * 方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧压入栈中，每一个方法调用结束都会有一个栈帧被弹出。
    * 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过栈的最大深度，就会抛出StackOverFlowError。
    * 如果栈的内存大小允许动态扩展，那么当栈扩展时无法申请到足够的内存空间，则会抛出OutOfMemoryError。
  |栈帧组成|局部变量表|操作数栈|动态链接|方法返回类型|
  |:--:|:--:|:--:|:--:|:--:|
  ||主要存放编译期可知的各种数据类型，对象引用(reference)|主要作为方法调用的中转站，用于存放方法执行过程中产生的中间计算结果和临时变量会放在操作数栈中|主要服务一个方法需要调用其他方法的场景||
  
  * 本地方法栈： 与java虚拟机栈类似，虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机用到的Native方法服务。

  ## 垃圾回收机制
  * 内存分配和回收原则
    * 对象优先在Eden分配，当Eden区没有足够空间时会发起一次Minor GC。
    * 大对象直接进入老年代：有虚拟机动态决定的，与具体的垃圾回收器和相关参数有关，减少了新生代的垃圾回收频率和成本。
    * 长期存活的对象会进入老年代：Age计数器，如果Eden中对象经过第一次GC后仍存活并能被survivor容纳，将被移动到Survivor区（s0或s1），age设为1。每经历一：次GC，age++，默认到15时到老年代。
  * 死亡对象判断方法
    * 引用计数法：简单高效，但是很难解决对象之间循环引用的问题
    * 可达性分析算法：GC Roots不可达时会被回收
  * 如何判断一个常量是废弃常量
    * 当没有对象引用该字符串常量时候，说明是个废弃常量，如果发生内存回收时会被清理。
  * 如何判断一个无用类
    * 方法区主要回收的是无用的类，需要满足三个条件才算无用类
    * 该类的实例都已经被回收
    * 加载该类的ClassLoader已经被回收
    * 该类对应的java.lang.class对象没有被任何地方引用，无法在任何地方通过反射访问该类
  ## 垃圾回收算法
  * 标记清除算法
  * 复制算法
  * 标记整理算法
  * 分代收集算法
