## 进程和线程
* 进程是系统运行程序的基本单位，线程是比进程更小的执行单位。一个进程在执行中可以产生多个线程。
* 同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
* 总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程都是独立的，而各线程则不一定。线程执行开销小，不利于资源的管理和保护，进程则相反。

## 线程的生命周期和状态
* new：初始状态
* runnable：运行状态
* blocked：阻塞状态
* waiting： 等待状态
* time_waiting：超时等待状态
* terminated：终止状态

## 死锁的必要条件
* 互斥条件
* 请求与保持条件
* 不剥夺条件
* 循环等待条件

## 直接调用run方法
* 调用start() 方法可启动线程并使线程进入就绪状态，直接执行run方法不会以多线程方式执行（会在main线程下直接执行）

## volatile关键字
* 保证变量的可见性，声明volatile指示jvm这个变量共享且不稳定，每次使用他都到主存中进行读取。
* 防止jvm指令重排序，在对这个变量进行读写操作的时候，会通过插入特定的内存屏障来禁止指令重排序。
* 不保证原子性

## 乐观锁和悲观锁
* 悲观锁总是假设最坏情况，每次获取资源操作都会上锁。高并发情况下激烈的锁竞争会造成线程阻塞，大量的线程上下文切换增加系统开销。并且悲观锁还可能造成死锁。
* 乐观锁总是假设最好的情况，每次访问共享资源线程可以不停的执行，无需加锁也无需等待，只是在提交修改的时候去验证资源是否被其他线程修改。

## 如何使用乐观锁
* 乐观锁一般会使用版本号机制或CAS算法实现。
* CAS算法：
    * compare and swap，用一个预期值和要更新的变量值进行比较，两者相等才会进行更新
    * ABA问题，解决方法是追加版本号或者时间戳，AtomicStampedReference类中compareAndSet方法首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志
    * 自旋操作，会带来大量的执行开销
    * 只对单个共享变量有效，可以将多个变量放在一个对象里

## Synchronized
* 解决多个线程之间访问资源的同步性，可以保证被他修饰的方法或者代码块在任意时刻都只能有一个线程执行。
* 修饰静态方法时对类加锁，修饰实例方法是给对象加锁。

## ReentrantLock
* 实现了Lock接口，是一个可重入且独占式的锁，比sychronized更灵活。
* 默认使用非公平锁
* ReentrantLock是jdk层面实现的（需要lock() unlock()配合try/finnaly来完成），sychronized是依赖jvm实现的。
* 等待可中断、可实现公平锁、可实现选择性通知

## AQS
* AbstractQueuedSynchronizer，抽象队列同步器。
* 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
* 如果被请求的共享资源被占用，则需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制用CLH队列锁实现，即将暂时获取不到锁的线程加入队列中。
